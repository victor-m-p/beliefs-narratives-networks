{% extends "global/Page.html" %} {% load static %} {% block scripts %}
<script src="{% static 'otreesurvey_app/canvasflex.js' %}?v=2025092302"></script>
{% endblock %} {% block styles %}
<style>
  /* ---------- Instruction card ---------- */
  .instruction-card {
    border: 1px solid #e6e6e6;
    background: #fafafa;
    border-radius: 12px;
    padding: 14px 16px;
    margin-bottom: 14px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
  }
  .eyebrow {
    font-size: 1.25rem;
    font-weight: 700;
    color: #111;
    margin: 0.25rem 0 0.5rem;
  }

  /* ---------- Chips ---------- */
  .chip {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 999px;
    border: 1px solid #d9d9d9;
    background: #fff;
    color: #111;
    font-weight: 700;
  }
  .chip-blue {
    background: #8cc7caaa;
  }
  .chip-orange {
    background: #fff1de;
  }
  .chip-purple {
    background: #e9e3f5;
  }

  /* ---------- Layout ---------- */
  .canvas-row {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    margin: 0 0 15px 0;
  }

  #canvasContainer {
    position: relative;
    width: 585px;
    margin: 0;
  }
  #dragCanvas {
    border: 2px solid #111;
    border-radius: 4px;
    display: block;
    width: 585px;
    height: 585px;
  }

  /* ---------- Right-side help panel ---------- */
  .help-panel {
    flex: 0 0 340px;
    min-height: 585px;
    border: 1px solid #e6e6e6;
    background: #fff;
    border-radius: 12px;
    padding: 14px 16px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
    position: sticky;
    top: 10px;
  }
  .help-panel h4 {
    margin: 0 0 8px 0;
    font-size: 1.05rem;
    font-weight: 800;
    color: #111;
  }
  .help-panel ol {
    margin: 0.25rem 0 0.25rem 1.25rem;
  }

  /* ---------- Soft warning toast ---------- */
  #soft-warning {
    display: none;
    position: relative;
    top: 20px;
    padding: 10px 14px;
    border: 1px solid #e6a700;
    background: #fff7e6;
    border-radius: 8px;
    color: #663c00;
    font-weight: 600;
    z-index: 20;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
    max-width: 585px;
    text-align: left;
  }
</style>
{% endblock %} {% block content %}
<div class="instruction-card">
  <p class="eyebrow">Which things are in conflict with each other?</p>
  <p>
    On the previous page you connected things that support each other. We are
    also interested in things that are in conflict with each other. Please
    connect
    <span class="chip chip-blue">blue circles</span> that
    <span class="chip chip-orange">conflict with each other</span> for {{
    vignette_name }} personally. By conflict we mean that one thing contradicts
    or undermines another. Focus only on
    <span class="chip chip-orange">conflicting</span> connections.
  </p>
  <p class="muted">
    <b>Here is the vignette again for your reference:</b>
    <em>{{ vignette_html }}</em>
  </p>
</div>

<div class="canvas-row">
  <div>
    <div id="canvasContainer">
      <canvas id="dragCanvas" width="585" height="585"></canvas>
    </div>

    <p id="soft-warning"></p>
  </div>

  <aside class="help-panel" aria-label="How to connect circles">
    <h4>How to connect circles</h4>
    <ol>
      <li>
        Click a <span class="chip chip-blue">blue circle</span> to select it.
      </li>
      <li>
        Click another <span class="chip chip-blue">blue circle</span> to create
        a <span class="chip chip-orange">conflict</span> connection.
      </li>
      <li>Click the same pair again to remove the connection.</li>
    </ol>
    <p style="margin-top: 0.5rem; color: #555">
      <i>You can still move circles if this helps you organize things.</i>
    </p>
  </aside>
</div>

<input type="hidden" id="positions" name="training_positions_3" />
<input type="hidden" id="edges" name="training_edges_3" />
<input
  type="hidden"
  id="retry_count_neg"
  name="training_neg_retry_count"
  value="{{ training_neg_retry_count }}"
/>
<input type="hidden" id="attempts_page_neg" name="training_neg_attempts_page" />

{{ next_button }}

<script>
  document.addEventListener("DOMContentLoaded", function(){
    const canvas = document.getElementById("dragCanvas");
    const ctx = canvas.getContext("2d");

    const retryField    = document.getElementById("retry_count_neg");
    const attemptsField = document.getElementById("attempts_page_neg");

    const exampleIndex = {{ training_example_index }};
    const scenarioKey  = "{{ training_example_key }}";
    const scenarioName = "{{ vignette_name }}";
    const polarity     = "negative";

    const pageStart = performance.now();
    const attemptLog = [];

    function bumpRetry() {
      if (!retryField) return;
      const current = parseInt(retryField.value || "0", 10);
      retryField.value = String(current + 1);
    }

    // Data from backend
    const beliefLabels       = {{ belief_labels_json|safe }};
    const priorPoints        = {{ belief_points|safe }};
    const priorPositiveEdges = {{ belief_edges_json|safe }};

    // --- Taxonomy data from Python ---
    const ALLOWED_MAP       = {{ allowed_map_json|safe }};
    const STANCE_BY_ID      = {{ stance_id_to_text_json|safe }};
    const REQUIRED_NEG_KEYS = new Set({{ required_negative_json|safe }});

    // Map label -> id
    const LABEL_TO_ID = {};
    for (const [id, label] of Object.entries(STANCE_BY_ID)) {
      LABEL_TO_ID[label] = id;
    }

    function keyForLabels(labelA, labelB) {
      const idA = LABEL_TO_ID[labelA];
      const idB = LABEL_TO_ID[labelB];
      if (!idA || !idB) return null;
      return idA < idB ? `${idA}-${idB}` : `${idB}-${idA}`;
    }

    function labelsFromKey(key) {
      const [a, b] = key.split("-");
      return [STANCE_BY_ID[a], STANCE_BY_ID[b]];
    }

    // Build nodes
    const points = beliefLabels.map((label, i) => ({
      label,
      x: priorPoints[i].x,
      y: priorPoints[i].y
    }));

    // Start with no negative edges; positive edges stay only in priorPositiveEdges
    let edges = [];
    let selectedPoint = null;

    // --- Drag config from NoOverlap (no fallbacks) ---
    const DRAG_PX      = NoOverlap.UI.dragThresholdPx;
    const LONGPRESS_MS = NoOverlap.UI.longPressMs;
    const DEFAULT_R    = NoOverlap.DRAW_DEFAULTS.node.defaultRadius;

    let candidateDragPoint = null;
    let draggingPoint = null;
    let downInfo = null;
    let wasDragging = false;

    // ---- Attempt logging ----
    function snapshotAttempt(status, issues) {
      const elapsedMs = performance.now() - pageStart;

      const attempt = {
        example_index: exampleIndex,
        scenario_key: scenarioKey,
        scenario_name: scenarioName,
        polarity: polarity,          // "negative" here
        attempt_index: attemptLog.length,
        status: status,
        elapsed_ms: elapsedMs,
        click_timestamp: new Date().toISOString(),
        missing_required_keys: issues.missingRequired.map(k => String(k)),
        disallowed_keys: issues.disallowedNegatives.map(x => String(x.key)),
        positions: points.map(p => ({
          label: p.label,
          x: p.x,
          y: p.y,
        })),
        edges: edges.map(e => ({
          stance_1: e.from.label,
          stance_2: e.to.label,
          polarity: e.polarity,
          edge_timestamp: e.timestamp || null,
        })),
      };
      attemptLog.push(attempt);
    }

    function drawCanvas(){
      NoOverlap.drawGraph(ctx, canvas, { points, edges, selectedPoint }, {
        edge: { positive: "#998ec3", negative: "#f1a340", other: "#666666" }
      });
    }

    function getMousePos(e){
      const r = canvas.getBoundingClientRect();
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    function findPoint(pos){
      return points.find(p => Math.hypot(p.x - pos.x, p.y - pos.y) <= (p.radius ?? DEFAULT_R));
    }

    // --- Click to toggle a negative edge ---
    function toggleEdge(a, b){
      if (a === b) return; // no self-edges
      const existing = edges.find(e =>
        (e.from === a && e.to === b) || (e.from === b && e.to === a)
      );
      if (existing){
        edges.splice(edges.indexOf(existing), 1);
      } else {
        edges.push({
          from: a,
          to: b,
          polarity: "negative",
          timestamp: new Date().toISOString()
        });
      }
    }

    // --- Mouse interactions ---
    canvas.addEventListener("mousedown", e=>{
      const pos = getMousePos(e);
      const hit = findPoint(pos);
      candidateDragPoint = hit || null;
      draggingPoint = null;
      wasDragging = false;
      downInfo = { x: pos.x, y: pos.y, t: performance.now() };
    });

    canvas.addEventListener("mousemove", e=>{
      const pos = getMousePos(e);
      if (!draggingPoint) {
        const hoveringAny = NoOverlap.findPoint(pos, points);
        if (NoOverlap.setHovered(canvas, hoveringAny)) drawCanvas();
        canvas.style.cursor = hoveringAny ? "grab" : "default";
      }

      if (!draggingPoint && candidateDragPoint && downInfo) {
        const dx = pos.x - downInfo.x, dy = pos.y - downInfo.y;
        const dist = Math.hypot(dx, dy);
        const held = performance.now() - downInfo.t;
        if (dist >= DRAG_PX || held >= LONGPRESS_MS) {
          draggingPoint = candidateDragPoint;
          canvas.style.cursor = "grabbing";
        }
      }

      if (draggingPoint){
        NoOverlap.tryMove(
          draggingPoint, pos.x, pos.y, points, drawCanvas, undefined,
          (pt) => NoOverlap.flash(pt, drawCanvas)
        );
        wasDragging = true;
      }
    });

    canvas.addEventListener("mouseup", evt=>{
      const pos = getMousePos(evt), hit = findPoint(pos);
      if (!wasDragging && hit){
        if (!selectedPoint){
          selectedPoint = hit;
        } else if (selectedPoint === hit){
          selectedPoint = null;
        } else {
          toggleEdge(selectedPoint, hit);
          selectedPoint = null;
        }
        drawCanvas();
      }
      if (!wasDragging && !hit){
        if (selectedPoint){ selectedPoint = null; drawCanvas(); }
      }
      candidateDragPoint = null;
      draggingPoint = null;
      downInfo = null;
      wasDragging = false;
      canvas.style.cursor = "default";
    });

    canvas.addEventListener("mouseleave", ()=>{
      if (NoOverlap.clearHovered(canvas)) drawCanvas();
      candidateDragPoint = null;
      draggingPoint = null;
      downInfo = null;
      wasDragging = false;
      if (canvas.style.cursor !== "grabbing") canvas.style.cursor = "default";
    });

    document.addEventListener("keydown", (e)=>{
      if (e.key === "Escape" && selectedPoint){
        selectedPoint = null; drawCanvas();
      }
    });

    // --- Taxonomy issues: required + disallowed negatives ---
    function computeTaxonomyIssues() {
      const negativeKeys = new Map(); // key -> example edge
      edges.forEach(ev => {
        if (ev.polarity !== "negative") return;
        const key = keyForLabels(ev.from.label, ev.to.label);
        if (!key) return;
        if (!negativeKeys.has(key)) negativeKeys.set(key, ev);
      });

      const missingRequired = [];
      REQUIRED_NEG_KEYS.forEach(key => {
        if (!negativeKeys.has(key)) missingRequired.push(key);
      });

      const disallowedNegatives = [];
      negativeKeys.forEach((edge, key) => {
        const allowed = ALLOWED_MAP[key];
        if (!allowed) return;
        if (!allowed.includes("negative")) {
          disallowedNegatives.push({ key, edge });
        }
      });

      return { missingRequired, disallowedNegatives };
    }

    const nextBtn =
      document.querySelector("button[type=submit]") ||
      document.querySelector(".otree-btn-next");

    if (nextBtn) {
      nextBtn.addEventListener("click", e=>{
        e.preventDefault();
        const softWarningEl = document.getElementById("soft-warning");

        if (softWarningEl) {
          softWarningEl.style.display = "none";
          softWarningEl.innerHTML = "";
        }

        const issues = computeTaxonomyIssues();
        const hasIssues = (issues.missingRequired.length + issues.disallowedNegatives.length) > 0;

        if (hasIssues) {
          snapshotAttempt('failed', issues);
          bumpRetry();

          if (softWarningEl) {
            let html = "";

            if (issues.missingRequired.length) {
              html += "Please add a <b>conflict connection</b> between the following pairs:<br>";
              issues.missingRequired.forEach(key => {
                const [l1, l2] = labelsFromKey(key);
                html += `&bull; “${l1}” and “${l2}”<br>`;
              });
              html += "<br>";
            }

            if (issues.disallowedNegatives.length) {
              html += "The following pairs should <b>not</b> have a conflict connection in this example. Please remove these links:<br>";
              issues.disallowedNegatives.forEach(item => {
                const [l1, l2] = labelsFromKey(item.key);
                html += `&bull; “${l1}” and “${l2}”<br>`;
              });
            }

            softWarningEl.innerHTML = html;
            softWarningEl.style.display = "block";
          }
          return;
        }

        // no issues → final OK attempt
        snapshotAttempt('ok', issues);

        function normalizeEdge(e){
          const s1 = e.stance_1 ?? (e.from && e.from.label) ?? e.from;
          const s2 = e.stance_2 ?? (e.to   && e.to.label)   ?? e.to;
          return {
            stance_1: s1,
            stance_2: s2,
            polarity: e.polarity ?? 'other',
            timestamp: e.timestamp ?? null
          };
        }

        const merged = [
          ...(priorPositiveEdges || []).map(normalizeEdge),
          ...edges.map(normalizeEdge) // new negatives
        ];

        document.getElementById("positions").value = JSON.stringify(points);
        document.getElementById("edges").value     = JSON.stringify(merged);
        attemptsField.value                        = JSON.stringify(attemptLog);

        document.querySelector("form").submit();
      });
    }

    drawCanvas();
  });
</script>
{% endblock %}
