{% extends "global/Page.html" %} {% load static %} {% block scripts %}
<script src="{% static 'otreesurvey_app/canvasflex.js' %}?v=20250812338"></script>
{% endblock %} {% block styles %}
<style>
  /* ---------- General instructions ---------- */
  .instructions {
    border: 1px solid #e6e6e6;
    background: #fafafa;
    border-radius: 10px;
    padding: 1rem 1.25rem;
    margin-bottom: 1rem;
  }
  .instructions h3 {
    margin: 0 0 0.5rem 0;
    font-size: 1.05rem;
    color: #111;
  }
  .instructions p {
    margin: 0.35rem 0;
    color: #333;
  }
  .muted {
    color: #555;
  }
  .eyebrow {
    font-size: 1.25rem;
    font-weight: 700;
    color: #111;
    margin: 0.25rem 0 0.5rem;
  }

  /* ---------- Chips / pills ---------- */
  .pill {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 999px;
    font-weight: 700;
    border: 1px solid #d9d9d9;
    background: #fff;
    color: #111;
    line-height: 1.2;
  }
  .pill-blue {
    background: #8cc7caaa;
  }

  /* ---------- Layout: canvas left + staging column right ---------- */
  .play-and-stage {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    margin: 0 0 15px 0;
  }

  /* ---------- Canvas ---------- */
  #dragCanvas {
    border: 2px solid #111;
    border-radius: 4px;
    display: block;
    width: 585px;
    height: 585px;
    flex: 0 0 585px;
  }

  /* ---------- Staging column ---------- */
  .stage {
    flex: 0 0 340px;
    height: 585px;
    overflow: auto;
    border: 1px dashed #c9ced8;
    border-radius: 8px;
    padding: 10px;
    background: #f6f7fb;
  }
  .stage h4 {
    margin: 0 0 8px 0;
    font-size: 0.95rem;
    color: #333;
    font-weight: 700;
  }
  .stage-item {
    user-select: none;
    cursor: grab;
    background: #fff;
    border: 1px solid #d9d9d9;
    border-radius: 999px;
    padding: 6px 12px 6px 40px;
    margin: 8px 0;
    position: relative;
    word-break: break-word;
  }
  .stage-item:active {
    cursor: grabbing;
  }
  .stage-item .dot {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #8cc7ca;
    border: none;
  }

  /* ---------- Canvas drop affordance ---------- */
  #dragCanvas.drop-ok {
    box-shadow: 0 0 0 3px rgba(60, 130, 246, 0.35) inset;
  }
</style>
{% endblock %} {% block content %}

<div class="instructions">
  <p class="eyebrow">Which things go together?</p>
  <p class="muted">
    <b>Your task:</b> Place things that go together closer to each other. Do
    this based on how things go together for {{ vignette_name }} personally.
  </p>
  <p class="muted">
    <b>Instructions:</b>
    <em>
      Drag the items from the box on the right into the map on the left. You can
      rearrange items by dragging them around. When you are happy with your
      arrangement you can proceed by clicking the "Next" button.
    </em>
  </p>
  <p class="muted">
    <b>Here is the vignette for your reference:</b>
    <em>{{ vignette_html }}</em>
  </p>
</div>

<div class="play-and-stage">
  <!-- Fixed-size canvas (the box that counts) -->
  <canvas id="dragCanvas" width="585" height="585"></canvas>

  <!-- Staging column (outside the canvas) -->
  <div id="stage" class="stage" aria-label="Drag items from here into the box">
    <h4>Drag into the box →</h4>
    <!-- items injected from beliefLabels -->
  </div>
</div>

<input type="hidden" name="training_positions_1" id="training_positions_1" />
<input type="hidden" name="training_map_attempts_page" id="map_attempts_page" />

{{ next_button }}

<script>
  const beliefLabels = {{ belief_labels_json|safe }};
  const exampleIndex = {{ training_example_index }};
  const scenarioKey  = "{{ training_example_key }}";
  const scenarioName = "{{ vignette_name }}";
</script>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const canvas = document.getElementById('dragCanvas');
    const ctx = canvas.getContext('2d');
    const stageEl = document.getElementById('stage');
    const attemptsField = document.getElementById('map_attempts_page');

    const pageStart = performance.now();

    // Strict: rely on NoOverlap, no fallbacks
    const R = NoOverlap.DRAW_DEFAULTS.node.defaultRadius;

    // --- Stage (outside canvas) ---
    function buildStage(labels) {
      stageEl.innerHTML = '<h4>Drag into the box →</h4>';
      labels.forEach((label, idx) => {
        const el = document.createElement('div');
        el.className = 'stage-item';
        el.setAttribute('draggable', 'true');
        el.dataset.label = label;
        el.dataset.idx = String(idx);
        el.innerHTML = '<span class="dot" aria-hidden="true"></span>' + label;

        el.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/plain', JSON.stringify({ label, idx }));
          const dragImg = document.createElement('canvas');
          dragImg.width = dragImg.height = 2 * R + 8;
          const c = dragImg.getContext('2d');
          c.beginPath();
          c.arc(dragImg.width / 2, dragImg.height / 2, R, 0, Math.PI * 2);
          c.fillStyle = '#8cc7ca';
          c.fill();
          ev.dataTransfer.setDragImage(
            dragImg,
            dragImg.width / 2,
            dragImg.height / 2
          );
        });

        stageEl.appendChild(el);
      });
    }
    buildStage(beliefLabels);

    const inStage = new Set(beliefLabels.map((_, i) => i));

    // --- Nodes in the canvas ---
    let pointsOnCanvas = []; // {label, x, y}

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      NoOverlap.drawGraph(ctx, canvas, { points: pointsOnCanvas });
    }

    function getMousePos(evt, targetCanvas) {
      const rect = targetCanvas.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    function pointInsideCanvas(p) {
      const r = p.radius ?? R;
      return (
        p.x - r >= 0 &&
        p.x + r <= canvas.width &&
        p.y - r >= 0 &&
        p.y + r <= canvas.height
      );
    }

    function allPointsInsideCanvas() {
      if (pointsOnCanvas.length !== beliefLabels.length) return false;
      return pointsOnCanvas.every(pointInsideCanvas);
    }

    // Auto-place helper: nearest valid spot inside the canvas
    function findNearestFreeSpot(canvas, points, startX, startY) {
      const RADIUS = NoOverlap.DRAW_DEFAULTS.node.defaultRadius;
      const MIN_DIST = 2 * RADIUS + 2;

      const clamp = (x, y) => ({
        x: Math.max(RADIUS, Math.min(canvas.width - RADIUS, x)),
        y: Math.max(RADIUS, Math.min(canvas.height - RADIUS, y)),
      });

      let c0 = clamp(startX, startY);
      if (!NoOverlap.isTooClose(c0.x, c0.y, points, null, MIN_DIST)) return c0;

      const MAX_R = Math.max(canvas.width, canvas.height);
      const RAD_STEP = Math.max(2, Math.floor(RADIUS / 2));
      const ANG_STEP = 15 * (Math.PI / 180);

      for (let rad = RAD_STEP; rad <= MAX_R; rad += RAD_STEP) {
        for (let th = 0; th < Math.PI * 2; th += ANG_STEP) {
          const cx = startX + rad * Math.cos(th);
          const cy = startY + rad * Math.sin(th);
          const c = clamp(cx, cy);
          if (!NoOverlap.isTooClose(c.x, c.y, points, null, MIN_DIST)) {
            return c;
          }
        }
      }
      return { x: canvas.width / 2, y: canvas.height / 2 };
    }

    // Accept drops from stage into canvas
    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
      canvas.classList.add('drop-ok');
    });
    canvas.addEventListener('dragleave', () => {
      canvas.classList.remove('drop-ok');
    });
    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      canvas.classList.remove('drop-ok');

      const data = e.dataTransfer.getData('text/plain');
      if (!data) return;

      const { label, idx } = JSON.parse(data);
      if (!inStage.has(Number(idx))) return;

      const pos = getMousePos(e, canvas);
      const spot = findNearestFreeSpot(canvas, pointsOnCanvas, pos.x, pos.y);

      const p = { label, x: spot.x, y: spot.y };
      pointsOnCanvas.push(p);

      NoOverlap.flash(p, drawCanvas, 120);

      const item = stageEl.querySelector(`.stage-item[data-idx="${idx}"]`);
      if (item) item.remove();
      inStage.delete(Number(idx));

      drawCanvas();
    });

    // Inside-canvas drag
    let draggingPoint = null;
    let offsetX = 0,
      offsetY = 0;

    function findPoint(pos) {
      const defR = NoOverlap.DRAW_DEFAULTS.node.defaultRadius;
      return pointsOnCanvas.find(
        (p) => Math.hypot(p.x - pos.x, p.y - pos.y) <= (p.radius ?? defR)
      );
    }

    canvas.addEventListener('mousedown', function (e) {
      const pos = getMousePos(e, canvas);
      const hit = findPoint(pos);
      if (hit) {
        draggingPoint = hit;
        offsetX = pos.x - hit.x;
        offsetY = pos.y - hit.y;
        canvas.style.cursor = 'grabbing';
      }
    });

    canvas.addEventListener('mousemove', function (e) {
      const pos = getMousePos(e, canvas);

      const hoveringAny = NoOverlap.findPoint(pos, pointsOnCanvas);
      if (NoOverlap.setHovered(canvas, hoveringAny)) drawCanvas();
      if (!draggingPoint)
        canvas.style.cursor = hoveringAny ? 'grab' : 'default';

      if (draggingPoint) {
        const newX = pos.x - offsetX;
        const newY = pos.y - offsetY;

        NoOverlap.tryMove(
          draggingPoint,
          newX,
          newY,
          pointsOnCanvas,
          drawCanvas,
          undefined,
          (pt) => NoOverlap.flash(pt, drawCanvas)
        );
      }
    });

    canvas.addEventListener('mouseup', function () {
      draggingPoint = null;
      canvas.style.cursor = 'default';
    });

    canvas.addEventListener('mouseleave', function () {
      if (NoOverlap.clearHovered(canvas)) drawCanvas();
      if (canvas.style.cursor !== 'grabbing') canvas.style.cursor = 'default';
      draggingPoint = null;
    });

    // Submit (save + log attempt)
    const form = document.querySelector('form');
    const nextButton = document.querySelector(
      'button[type=submit], .otree-btn-next'
    );

    nextButton.addEventListener('click', function (e) {
      e.preventDefault();

      if (!allPointsInsideCanvas()) {
        alert('Please drag all statements into the box before continuing.');
        return;
      }

      // 1) store positions for next page, as before
      document.getElementById('training_positions_1').value =
        JSON.stringify(pointsOnCanvas);

      // 2) log this (single) map attempt for the scenario
      const elapsedMs = performance.now() - pageStart;
      const attempt = {
        example_index: exampleIndex,
        scenario_key: scenarioKey,
        scenario_name: scenarioName,
        elapsed_ms: elapsedMs,
        click_timestamp: new Date().toISOString(),
        positions: pointsOnCanvas.map((p) => ({
          label: p.label,
          x: p.x,
          y: p.y,
        })),
      };

      attemptsField.value = JSON.stringify([attempt]);

      form.submit();
    });

    drawCanvas();
  });
</script>

{% endblock %}
